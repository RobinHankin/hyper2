---
title: "exponential Bradley-Terry"
author: "robin hankin"
date: "2025-04-02"
output: html_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(hyper2)
library(stringr)
library("partitions")
library("magrittr")
set.seed(0)
```

<font size="1">
(takes maybe two or three hours to run without cache; each
<tt>parkrunlikefunobs</tt> chunk takes maybe thirty minutes).
</font>

Basic idea is to have $n$ competitors with BT strengths $\beta, \beta
x,\ldots \beta x^{n-1}$ with $x\in[0,1]$.  The unit sum constraint
gives $\beta=\frac{1-x}{1-x^n}$ but this usually cancels out.  One of
the competitors is the _focal_ competitor with BT strength $\beta
x^{r-1}$ for some $r$ with $1\leqslant r < n$.  Thus $r=1$ means that
the focal competitor is the strongest among the $n$, $r=2$ means he is
the second, and so on.

# Some simple cases


We consider the smallest non-trivial cases $n=3$ and $n=4$.  For $n=3$
we have Plackett-Luce strengths $\alpha x,\alpha x^2,\alpha x^3$ [the
  extra factor of $x$ allows us to identify the $r$ in ``$\alpha x^r$''
  with the rank of the competitor, the best being rank 1].  Suppose
the focal competitor came first, the likelihood function would be

\begin{equation}
  \mathcal{L}(x,r)=\frac{x^{r-1}}{1+x+x^2}\qquad r=1,2,3
\end{equation}

```{r plot123first}
worker_123first <- function(...){
f <- function(x,r){ x^r/(x + x^2 + x^3) }

x <- seq(from=0.01 , to=1, by=0.01)
plot(c(-3,0), c(-3,0), type='n',
     xlab="log x", ylab="log-likelihood",main="(a)")
points(log(x),log(f(x,1)), type="l", col="black")
points(log(x),log(f(x,2)), type="l", col="red"  )
points(log(x),log(f(x,3)), type="l", col="blue" )

abline(h=0, lty=2)
abline(h = -2)
e <- exp(1)
r2reject <- ((e^2-1)-sqrt(e^4-2*e^2-3))/2
segments(x0=log(r2reject), y0=-2.2,y1=-1.8)

r3reject <- (1+sqrt(1+4*(e^2-1)))/(2*(e^2-1))
segments(x0=log(r3reject), y0=-2.2,y1=-1.8)
legend(x= -3, y= - 0.5, lty=1, col=c("black","red","blue"),
       legend=c("r=1","r=2","r=3"))
}
e <- exp(1)
r2reject <- ((e^2-1)-sqrt(e^4-2*e^2-3))/2
print(r2reject)
r3reject <- (1+sqrt(1+4*(e^2-1)))/(2*(e^2-1))
print(r3reject)

worker_123first()
pdf(file="123first.pdf")
worker_123first()
dev.off()


```

If the focal competitor came second we would have two Plackett-Luce
probabilities to add, corresponding to different order statistics.
$\alpha x^i$ or $\alpha x^j$ coming first where $i,j\neq r$.  For
example, if $r=1$ we would have two finishing orders that are
consistent with the observation: $2\succ 1\succ 3$ and $3\succ 1\succ
2$.  These are disjoint so the likelihood will be proportional to

$$
\frac{x^2}{x+x^2+x^3}\cdot\frac{x}{x+x^3} + 
\frac{x^3}{x+x^2+x^3}\cdot\frac{x}{x+x^2}
$$

After simplification:

\begin{equation}
  \mathcal{L}(x,r)=
  \begin{cases}
    \frac{x  }{x+x^2+x^3}\left(\frac{x^2}{x+x^3}   + \frac{x^3}{x+x^2}\right)\qquad r=1\\
    \frac{x^2}{x+x^2+x^3}\left(\frac{x  }{x^2+x^3} + \frac{x^3}{x+x^2}\right)\qquad r=2\\
    \frac{x^3}{x+x^2+x^3}\left(\frac{x  }{x^2+x^3} + \frac{x^2}{x+x^3}\right)\qquad r=3
\end{cases}
\end{equation}


```{r plot123second}
worker_123second <- function(...){
like <- function(x,r){
  S <- x + x^2 + x^3
  switch(r,
         '1' = x^2/S*x^1/(x^1+x^3) + x^3/S*x^1/(x^1+x^2), # 213+312
         '2' = x^1/S*x^2/(x^2+x^3) + x^3/S*x^2/(x^1+x^2), # 123+321
         '3' = x^1/S*x^3/(x^2+x^3) + x^2/S*x^3/(x^1+x^3)  # 132+231
  )
}

x <- seq(from=0.01, to=1, by=0.01)
plot(c(-3,0),c(-3,0), type='n',
     xlab="log x", ylab="log-likelihood", main="(b)")
points(log(x),log(like(x,1)), type="l", col="black")
points(log(x),log(like(x,2)), type="l", col="red"  )
points(log(x),log(like(x,3)), type="l", col="blue" )

abline(h=0,lty=2)
abline(h=-2)

legend(x = -3, y = -0.5, lty=1, col=c("black","red","blue"),
       legend=c("r=1", "r=2", "r=3"))
}
worker_123second()
pdf(file="123second.pdf")
worker_123second()
dev.off()
```

Now the focal competitor comes last:


```{r plot123third}
worker_123third <- function(...){
like <- function(x,r){
  S <- x + x^2 + x^3
  switch(r,
         '1' = x^3/S*x^2/(x^1+x^2) + x^2/S*x^3/(x^1+x^3), # 213+312
         '2' = x^1/S*x^3/(x^2+x^3) + x^3/S*x^1/(x^1+x^2), # 123+321
         '3' = x^1/S*x^2/(x^2+x^3) + x^2/S*x^1/(x^1+x^3)  # 132+231
  )
}

x <- seq(from=0.01, to=1, by=0.01)
plot(c(-3,0),c(-3,0),type='n',
     xlab="log x", ylab="log-likelihood", main="(c)")
points(log(x),log(like(x,1)), type="l", col="black")
points(log(x),log(like(x,2)), type="l", col="red"  )
points(log(x),log(like(x,3)), type="l", col="blue" )

abline(h=0,lty=2)
abline(h=-2)

legend(x = -3, y = -0.5, lty=1, col=c("black", "red", "blue"),
       legend=c("r=1", "r=2", "r=3"))
}

worker_123third()
pdf(file="123third.pdf")
worker_123third()
dev.off()
```


```{r allthree}
worker_allthree <- function(...){
op <- par(mfrow=c(1,3))
worker_123first()
worker_123second()
worker_123third()
dev.off()
par(op)
}
worker_allthree()
pdf(file="123all.pdf",height=4)
worker_allthree()
dev.off()
```
The $n=4$ case is harder as we potentially have six consistent
orderings for each observation.  As an example, if the focal
competitor comes third we have

\begin{equation}
\newcommand{pl}[4]{
\frac{x^{#1}}{x^{#1} + x^{#2} + x^{#3} + x^{#4}}\cdot
\frac{x^{#2}}{         x^{#2} + x^{#3} + x^{#4}}\cdot
\frac{x^{#3}}{                  x^{#3} + x^{#4}}}

\end{equation}


SDAdsfDSFFDSAfdsafdsff asdf dfs dfs dfs dsff dsfds fds fds sfd s fs sd sdf sdf sdf sdf sdf sdf sdf sdfs dfsdf sdsdfsa asdf saf

\begin{eqnarray}
\mathcal{L}(x;r=1)
\quad &=& \quad\hphantom{+}
            \pl{2}{3}{1}{4}\\
&{}&\quad + \pl{2}{4}{1}{3}\\
&{}&\quad + \pl{3}{2}{1}{4}\\
&{}&\quad + \pl{3}{4}{1}{2}\\
&{}&\quad + \pl{4}{2}{1}{3}\\
&{}&\quad + \pl{4}{3}{1}{2}
\end{eqnarray}

\begin{eqnarray}
\mathcal{L}(x;r=2) 
\quad &=& \quad\hphantom{+}
            \pl{1}{3}{2}{4}\\
&{}&\quad + \pl{1}{4}{2}{3}\\
&{}&\quad + \pl{3}{1}{2}{4}\\
&{}&\quad + \pl{3}{4}{2}{1}\\
&{}&\quad + \pl{4}{1}{2}{3}\\
&{}&\quad + \pl{4}{3}{2}{1}
\end{eqnarray}

and so on.


```{r fourcompetitors}
PL <- function(v){
  stopifnot(length(v) == 4)
  v[1]/(v[1]+v[2]+v[3]+v[4]) *
  v[2]/(     v[2]+v[3]+v[4]) *
  v[3]/(          v[3]+v[4])
}


f1 <- function(v){  # focal competitor came third, r=1
  return(
  PL(v^c(2,3,1,4)) +
  PL(v^c(2,4,1,3)) +
  PL(v^c(3,2,1,4)) +
  PL(v^c(3,4,1,2)) +
  PL(v^c(4,2,1,3)) +
  PL(v^c(4,3,1,2))
  )
}
f2 <- function(v){  # focal competitor came third, r=2
  return(
  PL(v^c(1,3,2,4)) +
  PL(v^c(1,4,2,3)) +
  PL(v^c(3,1,2,4)) +
  PL(v^c(3,4,2,1)) +
  PL(v^c(4,1,2,3)) +
  PL(v^c(4,3,2,1))
  )
}
f3 <- function(v){  # focal competitor came third, r=2
  return(
  PL(v^c(1,2,3,4)) +
  PL(v^c(1,4,3,2)) +
  PL(v^c(2,1,3,4)) +
  PL(v^c(2,4,3,1)) +
  PL(v^c(4,1,3,2)) +
  PL(v^c(4,2,3,1))
  )
}
f4 <- function(v){  # focal competitor came third, r=4
  return(
  PL(v^c(1,2,4,3)) +
  PL(v^c(1,3,4,2)) +
  PL(v^c(2,1,4,3)) +
  PL(v^c(2,3,4,1)) +
  PL(v^c(3,1,4,2)) +
  PL(v^c(3,2,4,1))
  )
}


worker <- function(...){

o <- 1:4

plot(c(-3,0),c(-3,0), type='n',
     xlab="log x", ylab="log-likelihood", main="Focal competitor came third")
x <- seq(from=0.01,to=1,by=0.001)

points(log(x),log(sapply(x,f1)), type="l", col="black")
points(log(x),log(sapply(x,f2)), type="l", col="red")
points(log(x),log(sapply(x,f3)), type="l", col="blue")
points(log(x),log(sapply(x,f4)), type="l", col="green")

abline(h=0,lty=2)
abline(h = -2, lty=1, col="gray")
           
legend("topright",lty=1,col=c("black", "red", "blue", "green"),
       legend=c("r=1", "r=2", "r=3", "r=4"), bg="white")


f1_solve <- function(x){log(sapply(exp(x), f1)) + 2}
f2_solve <- function(x){log(sapply(exp(x), f2)) + 2}
f4_solve <- function(x){log(sapply(exp(x), f4)) + 2}

root1 <- uniroot(f1_solve, c(-3,-0.1))$root
root2 <- uniroot(f2_solve, c(-3,-0.1))$root
root4 <- uniroot(f4_solve, c(-3,-0.1))$root

segments(x0=root1, y0=-2.1, y1=-1.9, col="gray")
segments(x0=root2, y0=-2.1, y1=-1.9, col="gray")
segments(x0=root4, y0=-2.1, y1=-1.9, col="gray")

print(c(root1, root2, root4))
} # worker() def closes



worker()
pdf(file="1234third.pdf")
worker()
dev.off()


```


# Try 8 competitors, focal competitor comes third


```{r calconetoeight, cache=TRUE}
pl <- function(v){
  out <- 1
  n <- length(v)
  for(i in seq_len(n-1)){
    out <- out*v[i]
    out <- out/sum(v[seq(from=i, to=n)])
  }
  return(out)
}

f <- function(x, place, no_of_comp){
    M <- perms(no_of_comp)
    out <- rep(0, no_of_comp)
    for(i in seq_len(ncol(M))){
        out[M[place,i]] %<>% `+`(pl(x^M[,i]))
    }
    return(out)
}

n <- 8
place <- 3
x <- seq(from = 0.1, to=1, by=0.01)
L <- matrix(0, length(x), n)
for(i in seq_along(x)){
    L[i,] <- f(x[i], place, n)
}
```

```{r onetoeight}
worker <- function(...){
    matplot(log(x),log(L), type='l', lty=1,ylim=c(-4,0))
}
pdf(file = "onetoeight.pdf")
worker()
dev.off()
worker()
```

# More stuff






```{r defineBT}
BT <- function(n,x){
    out <- x^(0:(n-1))
    if(x != 1){
        out <- out*(1-x)/(1-x^n)
    } else {
        out <- out/n
    }
    names(out) <- paste0("p",str_pad(1:n,ceiling(log10(n))))
    out
}
BT(4,0.5)
sum(BT(4,0.5))
```

We will consider $n=9$, $x=0.5$, $r=4$ and make repeated observations:


```{r showtabulate}
(jj <- BT(9,0.5))
o <- tabulate(replicate(1e4,which(rrace(jj) == "p4")))
o
plot(o,type='h')
```


    
```{r definegetprob, caasdf=TRUE}
getprob <- function(n, r, x, N=1e4){
    jj <- BT(n, x)
    wanted <- paste0("p", str_pad(r ,ceiling(log10(n))))
    c(r=r, x=x, setNames(tabulate(replicate(N, which(rrace(jj) == wanted)),nbins=n), paste0("p", 1:n)))
}
rbind(
getprob(9,1,0.5,N=100),
getprob(9,2,0.5,N=100),
getprob(9,3,0.5,N=100),
getprob(9,4,0.5,N=100),
getprob(9,5,0.5,N=100),
getprob(9,6,0.5,N=100),
getprob(9,7,0.5,N=100),
getprob(9,8,0.5,N=100),
getprob(9,9,0.5,N=100)
)

rbind(
getprob(9,1,0.2,N=100),
getprob(9,2,0.2,N=100),
getprob(9,3,0.2,N=100),
getprob(9,4,0.2,N=100),
getprob(9,5,0.2,N=100),
getprob(9,6,0.2,N=100),
getprob(9,7,0.2,N=100),
getprob(9,8,0.2,N=100),
getprob(9,9,0.2,N=100)
)
rbind(
getprob(9,1,0.9,N=100),
getprob(9,2,0.9,N=100),
getprob(9,3,0.9,N=100),
getprob(9,4,0.9,N=100),
getprob(9,5,0.9,N=100),
getprob(9,6,0.9,N=100),
getprob(9,7,0.9,N=100),
getprob(9,8,0.9,N=100),
getprob(9,9,0.9,N=100)
)
```

```{r makeII, cache=TRUE}
r_try <- 1:9
x_try <- seq(from = 0.1, to = 1, by = 0.05)
jj <- as.matrix(expand.grid(r_try, x_try))
II <- t(apply(jj, 1, function(v){getprob(9, v[1], v[2], N=1e4)}))
head(II)
```


```{r makesupp, cache=TRUE}
r_true <- 3
x_true <- 0.85
set.seed(0)
o <- getprob(9, r_true, x_true, 100)  # observations
o[1:2]
o[-(1:2)]

support_func <- function(o, v){
    v <- v[-(1:2)]
    v <- v/sum(v)
    dmultinom(o[-(1:2)], prob=v, log=TRUE)
}
support <- rep(0,nrow(II))
for(i in seq_len(nrow(II))){
    support[i] <- support_func(o, II[i,])
}
```
    
```{r plottoycontour}
x_try
length(support)
support <- support-max(support)
support <- pmax(support, -10)
support  <- matrix(support,length(r_try),length(x_try))
wanted <- x_try >= 0.5
worker <- function(...){
contour(r_try, x_try[wanted], support[,wanted], xlab="r", ylab="x", levels = -c(1,(1:5)*2), lwd=c(1,3,1,1,1,1))
points(r_true,x_true,pch=16,col='red',cex=2)
jj <- support[,wanted]
maxplace <- which(jj==max(jj), arr.ind=TRUE)
points(r_try[maxplace[1]], x_try[wanted][maxplace[2]], pch=16, col='blue', cex=2)
}
worker()
pdf(file="toyexample.pdf")
worker()
dev.off()

filled.contour(r_try, x_try, support, xlab = "r", ylab = "x")
```

```{r contourLO}
x_try
wanted <- 8:18
LO <- function(p){log(p/(1-p))}
contour(r_try, LO(x_try[wanted]), support[,wanted], xlab="r", ylab="Log-odds of x", levels = -c(1,(1:5)*2), lwd=c(1,3,1,1,1,1))
```

```{R showjj}
jj <- cbind(II[,1:2],c(support))
jj[jj[,2] == 1,]
```

#  Analysis from a single observation


We translate $\alpha\in [0,1]$ to a number from 1 to $n$ inclusive
with $\lceil n\alpha\rceil$

Write a likelihood function for 9,12 [that is, came 9th in a class of
12] There are 8 better and 3 worse than the focal student.


```{r ninetwelve}
single_like_fun <- function(n, a,          # n competitors, places a [e.g a=3 -> third]
                            a_try, x_try,  # values to try
                            N=1e2){        # N is number of trials
    p_try <- ceiling(n * a_try)
    jj <- as.matrix(expand.grid(p_try, x_try))
    II <- t(apply(jj,1,function(v){getprob(n, v[1], v[2], N)}))
    matrix(II[, ceiling(a*n) + 2], length(a_try), length(x_try))
}
```


```{r makesupp912, cache=TRUE}
a_try <- seq(from = 0.01, to = 0.99, len = 10)
x_try <- seq(from = 0.2, to = 1, by = 0.1)
allsupp <- list(
    log(single_like_fun(12, a =  8/12, a_try, x_try)),  # pure
    log(single_like_fun(17, a = 12/17, a_try, x_try)),  # pure
    log(single_like_fun(23, a = 18/23, a_try, x_try)),  # pure
    log(single_like_fun(14, a =  5/14, a_try, x_try)),  # applied
    log(single_like_fun(13, a =  3/13, a_try, x_try)),  # applied
    log(single_like_fun(11, a =  2/11, a_try, x_try)),  # applied
    log(single_like_fun(13, a =  3/13, a_try, x_try))   # applied
)
```

```{r showallsupp}
S <- Reduce("+",allsupp)
S <- pmax(S-max(S),-10)
contour(a_try, x_try, S, levels = -1*(1:7))
jj <- which(S == max(S), arr.ind = TRUE)
points(a_try[jj[1]], x_try[jj[2]], pch=16, col = 'red')
```


```{r showbothsupp}
S_pure    <- Reduce("+", allsupp[1:3])
S_applied <- Reduce("+", allsupp[4:7])
S_all     <- Reduce("+", allsupp[1:7])
max(S_all)
max(S_pure)
max(S_applied)
max(S_pure) + max(S_applied)
max(S_pure) + max(S_applied) - max(S_all)
pchisq(max(S_pure) + max(S_applied) - max(S_all),df=2,lower.tail=FALSE)
```

# Parkrun

In the following chunks, each execution of
`single_like_fun(...,N=1000)` takes  about 5 minutes

```{r sethowmany}
howmany <- 1000  # this is a low value.  See baht for higher and more accurate values.
competitors <- c(43, 49, 59, 51, 56, 55, 58)
set.seed(0)
rank <- c(37, 39, 50, 43, 46, 41, 45)
plot(rank/competitors)
```

```{r parkrunlikefunobs1, cache = TRUE}
print(system.time(parkrun01 <- single_like_fun(competitors[1], rank[1]/competitors[1], N = howmany, a_try, x_try)))
```

```{r}
parkrun01
```

```{r parkrunlikefunobs2, cache = TRUE}
print(system.time(parkrun02 <- single_like_fun(competitors[2], rank[2]/competitors[2], N = howmany, a_try, x_try)))
```

```{r}
parkrun02
```

```{r parkrunlikefunobs3, cache = TRUE}
print(system.time(parkrun03 <- single_like_fun(competitors[3], rank[3]/competitors[3], N = howmany, a_try, x_try)))
```

```{r}
parkrun03
```

```{r parkrunlikefunobs4, cache = TRUE}
print(system.time(parkrun04 <- single_like_fun(competitors[4], rank[4]/competitors[4], N = howmany, a_try, x_try)))
```

```{r}
parkrun04
```

```{r parkrunlikefunobs5, cache = TRUE}
print(system.time(parkrun05 <- single_like_fun(competitors[5], rank[5]/competitors[5], N = howmany, a_try, x_try)))
```

```{r}
parkrun05
```
 
```{r parkrunlikefunobs6, cache = TRUE}
print(system.time(parkrun06 <- single_like_fun(competitors[6], rank[6]/competitors[6], N = howmany, a_try, x_try)))
```

```{r}
parkrun06
```

```{r parkrunlikefunobs7, cache = TRUE}
print(system.time(parkrun07 <- single_like_fun(competitors[7], rank[7]/competitors[7], N = howmany, a_try, x_try)))
```

```{r}
parkrun07
```


```{r}
c(
sum(parkrun01),
sum(parkrun02),
sum(parkrun03),
sum(parkrun04),
sum(parkrun05),
sum(parkrun06),
sum(parkrun07)
)
```

```{r}
contour(a_try,x_try,parkrun05)
contour(a_try,x_try,parkrun06)
(p <- parkrun01*parkrun02*parkrun03*parkrun04*parkrun05*parkrun06*parkrun07)
contour(a_try, x_try, p)
LL <- log(p)
LL <- LL - max(LL)
LL
contour(a_try, x_try, LL, levels=c(0,-1,-2,-4,-6))
filled.contour(a_try, x_try, LL)
```


```{r}
pdash <-
     (parkrun01+1) * 
     (parkrun02+1) * 
     (parkrun03+1) * 
     (parkrun04+1) * 
     (parkrun05+1) * 
     (parkrun06+1) * 
    (parkrun07+1)
pdash
LLd <- log(pdash)
(LLd <- LLd - max(LLd))
contour(a_try, x_try, LLd, levels=c(0,-1,-2,-4,-6))
wanted_a <- (a_try) > 0.6
contour(a_try[wanted_a], x_try, LLd[wanted_a,], levels = rev(c(0,-1,-2,-4,-6)))
filled.contour(a_try[wanted_a], x_try, LLd[wanted_a,], levels = rev(c(0,-1,-2,-4,-6)))
```

Now use pre-calculated values [Blue Peter style]


```{r, label=precalculatedfrombaht}
x <-
list(structure(c(1, 1, 1, 1, 1, 1, 1, 17, 6669, 2, 1, 1, 1, 1, 
1, 1, 1, 166, 7920, 29, 1, 1, 1, 1, 1, 1, 1, 785, 8251, 85, 1, 
1, 1, 1, 1, 1, 1, 2206, 7673, 275, 1, 1, 1, 1, 1, 1, 1, 4039, 
6740, 603, 1, 1, 1, 1, 1, 1, 86, 5112, 5447, 1147, 1, 1, 1, 1, 
1, 20, 1079, 4493, 4302, 1810, 1, 1, 1, 42, 350, 1030, 2190, 
2976, 2845, 2254, 1162, 1172, 1209, 1168, 1172, 1161, 1255, 1114, 
1143, 1198), dim = 10:9), structure(c(1, 1, 1, 1, 1, 1, 1, 8799, 
15, 1, 1, 1, 1, 1, 1, 1, 1, 11379, 71, 1, 1, 1, 1, 1, 1, 1, 1, 
12364, 236, 1, 1, 1, 1, 1, 1, 1, 2, 11674, 561, 13, 1, 1, 1, 
1, 1, 1, 106, 9480, 999, 78, 1, 1, 1, 1, 1, 1, 905, 6744, 1528, 
245, 1, 1, 1, 1, 1, 198, 2466, 4262, 1883, 697, 1, 1, 6, 92, 
484, 1543, 2258, 2337, 1855, 1188, 1015, 1040, 1057, 1040, 1012, 
1102, 1035, 942, 1020, 1005), dim = 10:9), structure(c(1, 1, 
1, 1, 1, 1, 1, 1, 1351, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2483, 1, 1, 
1, 1, 1, 1, 1, 1, 61, 3395, 7, 1, 1, 1, 1, 1, 1, 1, 456, 4164, 
34, 1, 1, 1, 1, 1, 1, 1, 1723, 4205, 123, 1, 1, 1, 1, 1, 1, 3, 
3438, 3982, 413, 1, 1, 1, 1, 1, 1, 368, 3811, 3280, 830, 1, 1, 
1, 1, 38, 411, 1737, 2467, 2243, 1451, 878, 894, 853, 770, 824, 
841, 826, 911, 816, 832), dim = 10:9), structure(c(1, 1, 1, 1, 
1, 1, 1, 19, 1376, 1, 1, 1, 1, 1, 1, 1, 1, 160, 2460, 3, 1, 1, 
1, 1, 1, 1, 1, 763, 3501, 16, 1, 1, 1, 1, 1, 1, 1, 2177, 4082, 
52, 1, 1, 1, 1, 1, 1, 1, 4121, 4250, 243, 1, 1, 1, 1, 1, 1, 20, 
5133, 4004, 543, 1, 1, 1, 1, 1, 4, 659, 4339, 3428, 1095, 1, 
1, 1, 12, 148, 864, 1913, 2709, 2363, 1660, 989, 949, 1005, 1004, 
974, 982, 994, 965, 922, 1006), dim = 10:9), structure(c(1, 1, 
1, 1, 1, 1, 1, 742, 51, 1, 1, 1, 1, 1, 1, 1, 1, 2117, 254, 1, 
1, 1, 1, 1, 1, 1, 1, 4292, 554, 3, 1, 1, 1, 1, 1, 1, 1, 6318, 
1064, 16, 1, 1, 1, 1, 1, 1, 1, 7210, 1641, 57, 1, 1, 1, 1, 1, 
1, 105, 6367, 2072, 256, 1, 1, 1, 1, 1, 12, 1184, 4367, 2340, 
733, 1, 1, 1, 7, 109, 915, 2072, 2402, 2018, 1243, 893, 890, 
881, 878, 859, 865, 885, 935, 896, 907), dim = 10:9), structure(c(1, 
1, 1, 1, 1, 1, 1, 1412, 1, 1, 1, 1, 1, 1, 1, 1, 4, 2428, 3, 1, 
1, 1, 1, 1, 1, 1, 61, 3354, 14, 1, 1, 1, 1, 1, 1, 1, 468, 4045, 
69, 1, 1, 1, 1, 1, 1, 1, 1749, 4255, 231, 7, 1, 1, 1, 1, 1, 6, 
3488, 3925, 583, 69, 1, 1, 1, 1, 1, 414, 3674, 2991, 1002, 269, 
1, 1, 5, 81, 654, 1653, 2223, 1895, 1250, 735, 889, 906, 891, 
892, 912, 947, 936, 896, 951, 872), dim = 10:9), structure(c(1, 
1, 1, 1, 1, 1, 1, 32060, 1, 1, 1, 1, 1, 1, 1, 1, 1, 24428, 6, 
1, 1, 1, 1, 1, 1, 1, 1, 18200, 37, 1, 1, 1, 1, 1, 1, 1, 3, 13287, 
132, 2, 1, 1, 1, 1, 1, 1, 103, 9278, 377, 13, 1, 1, 1, 1, 1, 
1, 999, 6070, 716, 94, 1, 1, 1, 1, 1, 90, 2543, 3786, 1247, 318, 
1, 1, 1, 25, 280, 1325, 2279, 2237, 1419, 867, 865, 899, 871, 
822, 898, 855, 866, 878, 885, 842), dim = 10:9))

L <- 1 + x[[1]]*0

for(i in 1:7){
    x[[i]] <- pmax(x[[i]],1)
    L <- L * x[[i]]
}

LL <- log(L)
LL <- LL - max(LL)

a_try <- seq(from = 0.01, to = 0.99, len = 10)
x_try <- seq(from = 0.2, to = 1, by = 0.1)

wanted_a <- (a_try) > 0.6
f <- function(...){
    contour(a_try[wanted_a], x_try,
            xlab="r", ylab="x",
            LL[wanted_a,], levels = rev(c(0,-1,-2,-4,-6)))
grid()
}
f()
pdf(file="parkrunlikelihood.pdf")
f()
dev.off()
```

## Formula 1


```{r checo}
n <- 20 # 20 drivers
multiple_like_fun <- function(n,           # n competitors
                            a_try, x_try,  # values to try
                            N=1e2){        # N is number of trials
    p_try <- ceiling(n * a_try)
    jj <- as.matrix(expand.grid(p_try, x_try))
    t(apply(jj,1,function(v){getprob(n, v[1], v[2], N)}))
}
```


```{r checo2023}

o <- c(5,5,2,6,6,4,2,3,8,3,4,4,6,6,3,5,2,8,7,9)  # Lewis Hamilton 2023
# o <- c(7,9,9,9,6,6,7,4,3,4,1,3,1,8,5,9,6,4,10,2,12,4) # Lewis Hamilton 2024
# o <- c(6,8,3,5,2,1,2,4,2,2,20,3,2,5,1,3,4,1,4,2,6,6,10) # lando norris 2024
```

```{r trymultx, cache=TRUE}
II <- multiple_like_fun(20, a_try,x_try,1e4)
head(II)
nrow(II)
length(a_try)
length(x_try)
```

```{r calcmultx, cache=TRUE}
like <- list()
dim(II)
o
for(i in seq_along(o)){
    like[[i]] <-  matrix(II[, o[i] + 2], length(a_try), length(x_try))
}
```

```{r showlike, cache=FALSE}
options(digits=5)
like
alllike <- Reduce("*",like)
alllike 
alllike/max(alllike)
S <- log(alllike)
S <- S-max(S)
S <- pmax(S,-15)
contour(a_try, x_try, S, levels = -(0:6)*1, lwd=c(1,4,1,1,1,1,1))

worker <- function(...){
    wanted <- a_try < 0.5
    contour(a_try[wanted], x_try, S[wanted,], levels = -(0:6)*2, lwd=c(1,4,1,1,1,1,1))
    jj <- S[wanted,]
    m <- which(jj == max(jj), arr.ind=TRUE)
    points(a_try[wanted][m[1]], x_try[m[2]], pch=16, cex=2, col='red')
}
worker()
pdf(file="formula1.pdf")
worker()
dev.off()
filled.contour(S)
```


## Formula 1 without Verstappen and three other low-performing drivers.


```{r readandcutout}
a <- read.table("~/rstudio/hyper2/inst/formula1_2023.txt")
a <- a[,-ncol(a)]
rownames(a)
```

```{r maxF1, cache=TRUE}
H <- ordertable2supp(as.ordertable(a))
m <- maxp(H)
```

```{r showF1max}
dotchart(log(m))
```

Above we see that Verstappen, Ricciardo, Lawson and deVries are
outliers.  We are going to get rid of them:

```{r, label=getridofverstappen}
a <- a[!(rownames(a) %in% c("Verstappen", "Ricciardo", "Lawson", "deVries")),]
print(a)
```

```{r converttohyper2, cache=TRUE}
H <- ordertable2supp(a)
m <- maxp(H)
```

```{r}
m <- sort(m, decreasing=TRUE)
dotchart(sort(log(m)))
```

Now we will find the optimal value of $x$:

```{r findbestx, cache=TRUE}
f <- function(x){
  out <- x^(0:17)
  out <- out/sum(out)
  setNames(out, names(m))
}

pnames(H) <- names(sort(m, decreasing=TRUE))
L <- function(x){loglik(f(x),H)}
L(0.60)
L(0.61)

xv <- seq(from=0.8,to=0.99,len=6)
Lv <- sapply(xv,L)
```

```{r}
plot(xv,Lv,type='b')
```










# Skating

```{r, startskating, cache=TRUE}
sk <- skating
pnames(sk) <- names(sort(skating_maxp, decreasing=TRUE))
maxp(sk)
```

```{r moreskating, cache=TRUE}
skater_strengths <- function(x){
    p <- BT(23, x)
    names(p) <- pnames(sk)
    return(p)
}
skater_strengths(0.5)
```


```{r doskating, cache=TRUE}
gvec <- seq(from=0.5, by=0.01, to=0.65)
f <- function(g){loglik(skater_strengths(g), sk)}
L <- sapply(gvec, f)
L <- L-max(L)
```

```{r}
plot(gvec,L,type="b")
abline(h = c(0,-2))
grid()
```


```{r testskating, cache=TRUE}
skater_strengths(0.57)
skating_test <- knownp.test(sk, skater_strengths(0.57))
skating_test
```

```{r}
xn <- skating_test$null_estimate
xa <- skating_test$alternative_estimate
xn <- log10(xn)
xa <- log10(xa)
par(pty="s")
plot(xn,xa,xlim=c(-6,0),ylim=c(-6,0))
abline(0,1)
```
