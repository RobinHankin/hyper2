---
title: "Person with advantage functionality for `hyper3` objects: `pwa3()`"
output: bookdown::html_document2
author: "Robin K. S. Hankin"
link-citations: true
bibliography: hyper2.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("hyper2")
```

```{r out.width='20%', out.extra='style="float:right; padding:10px"',echo=FALSE}
knitr::include_graphics(system.file("help/figures/hyper2.png", package = "hyper2"))
```


<font size="1"> (takes about five minutes to run without cache)
</font>


```{r}
pwa3
pwa3_single
```

To cite the `hyper2` package in publications, please use
@hankin2017_rmd.  Here we analyse some simple Plackett-Luce
observations, using `hyper3` likelihood functions.


Our observations are a total of six order statistics for four
competitors `a,b,c,d`.  These competitors race three times under
Plackett-Luce probabilities.  They then race three times, but with
competitor `b` having some advantage (steroids?), parametrized by his
Plackett-Luce strength being $\lambda b$.

Our object of inference is $\lambda$; the Plackett-Luce strengths
`a,b,c,d` are nuisance parameters.


```{r definelamf}
lam <- function(lambda){

  race_nohelp <-
    race(c("b","a","d","c")) + 
    race(c("c","b","a","d")) + 
    race(c("b","d","a","c")) 
    
  race_help <- 
    race(c("a","c","d","b")) |> pwa3(b = lambda) + 
    race(c("c","d","b","a")) |> pwa3(b = lambda) + 
    race(c("d","c","a","b")) |> pwa3(b = lambda)
  
  maxp(as.hyper3(race_nohelp) + race_help, give=TRUE)$value
}
```

Above we see that in the unaided case (the first three races), `b`
does quite well, coming first twice and second once.  In the aided
case, `b` does much worse, coming either third or fourth.  Evidently,
the "help" actually hinders `b` and we suspect that $\lambda<1$.


```{r calclamf, cache=TRUE}
l <- exp(seq(from=log(0.0002), to=log(2), len=17))
like <- sapply(l,lam)
```


```{r optimizelamf, cache=TRUE}
optimal_sol <- optimize(lam, c(0.01, 3), maximum=TRUE)
```

```{r showoptimlam}
optimal_sol
```

```{r lamfminus2, cache=TRUE}
f <- function(l){lam(l) - optimal_sol$objective + 2}
lower <- uniroot(f, interval = c(exp(-8), exp(-7)))
upper <- uniroot(f, interval = c(exp(-2), exp( 0)))
```

```{r plotlamf, echo=TRUE,fig.cap="Log-likelihood function for lambda"}
plot(log(l), like - optimal_sol$objective,
	     type='b', pch=16,
	     xlab = expression(log(lambda)),
	     ylab = "log-likelihood")
abline(h = c(0, -2), col='gray')
abline(v = log(optimal_sol$maximum))
abline(v = 0, lty=2)
segments(x0 = log(c(lower$root, upper$root)), y0 = -2.25, y1 = -1.75, col='gray')
```

Figure \@ref(fig:plotlamf) shows a log-likelihood function for
$\log\lambda$.  We see that the evaluate is about
$\lambda=\exp(`r round(log(optimal_sol$maximum),2)`)\simeq
`r round(optimal_sol$maximum,3)`$.  Further, the support interval
runs from about
$\exp(`r round(log(lower$root),2)`)\simeq `r round(lower$root,6)`$
to about
$\exp(`r round(log(upper$root),2)`)\simeq `r round(upper$root,2)`$
thereby excluding the null of $\lambda=1$
which has a support of about `r round(lam(1)-optimal_sol$objective,2)`.



# Another example {-}

In this case, competitor `a` receives help $\lambda$ or $\lambda^n$ if
he gets $n$ sets of help.  Below, in function `lam2()` we see that, in
general, the more help `a` gets, the better he does.  See how a
negative power corresponds to some sort of hindrance or penalty, and a
zero power (of course) corresponds to no help at all.

```{r lam2def}
lam2 <- function(lam){


  race_help <- 
    race(c("d","c","a","b")) |> pwa3(a = lam^0 ) +
    race(c("c","b","d","a")) |> pwa3(a = lam^-3) + 
    race(c("c","b","d","a")) |> pwa3(a = lam^-2) + 
    race(c("c","b","a","d")) |> pwa3(a = lam^-1) + 
    race(c("a","c","b","d")) |> pwa3(a = lam   ) + 
    race(c("a","c","b","d")) |> pwa3(a = lam^3 ) +
    race(c("a","b","d","c")) |> pwa3(a = lam   ) +
    race(c("c","a","d","b")) |> pwa3(a = lam^2 )

    maxp(race_help, give=TRUE)$value
}
```

```{r calclam2f, cache=TRUE}
l <- exp(seq(from=log(0.8), to=log(19.1), len=11))
like2 <- sapply(l,lam2)
```

```{r}
plot(log(l),like2-max(like2),type="b",pch=16)
abline(h=c(0,-2), col='gray')
abline(v=0, lty=2)
```

# Another other example {-}

In this example we see help being given to two competitors at the same
time.


```{r lam3def}

myr <- function(a1,a2,a3,a4,a5){race(letters[c(a1,a2,a3,a4,a5)])}

lam3 <- function(l){
  race_help <- 
    myr(3,1,2,4,5) |> pwa3(a=l, b=l) + 
    myr(2,3,1,4,5) |> pwa3(a=l, b=l) + 
    myr(3,1,5,4,2) |> pwa3(a=1, b=1) +   # no help!
    myr(4,2,5,3,1) |> pwa3(a=1, b=1) +   # no help!
    myr(3,1,2,4,5) |> pwa3(a=l, b=l)

    maxp(race_help, give=TRUE)$value
}
```

```{r calclam3, cache=TRUE}
l <- exp(seq(from=log(0.5), to=log(84.1), len=13))
like3 <- sapply(l,lam3)
```

```{r plotlam3}
plot(log(l),like3-max(like3), type="b", pch=16)
abline(h=c(0,-2), col='gray')
abline(v=0, lty=2)
```

# Yet another example {-}

Here we consider help in turn to each of five competitors.  From the
function below, if someone gets help they generally do quite well.

```{r lam4def}

myr <- function(a1,a2,a3,a4,a5){race(letters[c(a1,a2,a3,a4,a5)])}

lam4 <- function(x, givelike=FALSE){
    race_help <- 
        myr(3,1,2,4,5) |> pwa3(a=x) +
        myr(2,3,1,4,5) |> pwa3(b=x) +
        myr(3,1,5,4,2) |> pwa3(c=x) +
        myr(4,2,5,3,1) |> pwa3(d=x) +
        myr(3,5,2,4,1) |> pwa3(e=x)
    if(givelike){
        return(race_help)
    } else {
        return(maxp(race_help, give=TRUE)$value)
    }
}
```

```{r calclam4, cache=TRUE}
l <- exp(seq(from= -0.5, to=log(250), len=15))
like4 <- sapply(l,lam4)
```

```{r optimizelamf4, cache=TRUE}
optimal_sol4 <- optimize(lam4, exp(2:3), maximum=TRUE)
```

It makes sense to consider our likelihood function at the estimate for
$\lambda$:


```{r maxp4}
H <- lam4(optimal_sol4$maximum, givelike=TRUE)
H
summary(H)
maxp(H)
```

Above we see that the evaluate is very high for `c` having a BT
strength of about 0.6.  This is consistent with our observations for
twice we see `c` winning [that is, coming first] without any help.


```{r plotlam4}
plot(log(l),like4-max(like4), type="b", pch=16)
abline(h=c(0,-2), col='gray')
abline(v=0, lty=2)
abline(v = log(optimal_sol4$maximum))
```

### References {-}
