---
title: "Ternary plots for `hyper2` and `hyper3` samples"
author: "Robin Hankin"
output: bookdown::html_document2
bibliography: hyper2.bib
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, label=hexstickerplotter, out.width='15%', out.extra='style="float:right; padding:10px"',echo=FALSE}
knitr::include_graphics(system.file("help/figures/hyper2.png", package = "hyper2"))
```

<font size="1"> (takes about fifteen minutes to run without cache)
</font>

To cite the `hyper2` package in publications please use
@hankin2017_rmd.  Here I show how to use the excellent `Ternary`
package [@smith2017_rmd] to generate triangular plots for `hyper2` and
`hyper3` likelihood functions with size 3.


First load the `Ternary` and `hyper2` packages:

```{r loadlibraries}
suppressPackageStartupMessages(library("Ternary"))
suppressPackageStartupMessages(library("hyper2"))
```


# Ternary plots for a `hyper3` likelihood function.

Suppose we have a race between 4 `a`s, 2 `b`s and 2 `c`s.  The
finishing order was:


$$
a\succ a\succ a\succ a
\succ b\succ c
\succ a
\succ c\succ b
$$.

So it is clear that `a` is likely to be the strongest; it is not
immediately clear whether one would expect `b` or `c` to be stronger,
although both are substantially weaker than `a`.  Indeed:

```{r race3hyper3, cache=TRUE}
made_up_race <- c("a", "a", "a", "b", "c", "a", "c", "b", "c")
H_mu <- ordervec2supp3(made_up_race)
maxp(H_mu)
```

So it turns out that the MLE has `b` almost twice the strength of `c`.
[there is actually more difference between `b` and `c` than I would
expect from the observation].  Let's plot a ternary plot:

```{r}
ternary_contourplot <- function(H){
    stopifnot(size(H) == 3)

    FunctionToContour <- function (a, b, c) {
      M <- cbind(a, b, c)
      M[] <- pmax(M, 0)
      M <- sweep(M, 1, rowSums(M),"/")
      colnames(M) <- pnames(H)
      out <- loglik(M, H)
      out[is.infinite(out)] <- NA
      out <- out - max(out,na.rm = TRUE)
      out <- pmax(out, -20, na.rm = TRUE)
      return(out)
   }

   originalPar <- par(mar = rep(0, 4))
   jj <- pnames(H)
   TernaryPlot(atip = jj[1], btip = jj[2], ctip = jj[3])
   values <- TernaryPointValues(FunctionToContour, resolution = 24L)
   ColourTernary(
     values,
     legend = signif(seq(max(values), min(values), length.out = 4), 2),
     bty = "n"
   )
   TernaryContour(FunctionToContour, resolution = 72L, nlevels=10)
}
```

```{r label=plotmadeup, fig.cap="Contours of support", cache=TRUE}
ternary_contourplot(H_mu)
```

Figure \@ref(fig:plotmadeup) shows that the orientation and labelling
of the ternary plot is indeed consistent: `a` is clearly the
strongest, followed by `b`, followed by `c`.  We can get a different
perspective by sampling from the likelihood function:

```{r defineternarysamplefunction, fig.cap="Maximum likelihood estimates of synthetic datasets generated by the `rrace3()` random race function"}
ternary_sampleplot <- function(n, H, ...){
    stopifnot(size(H) == 3)
    jj <- pnames(H)
    startp <- maxp(H)
    x <- rp(n, H, startp = indep(startp))
    TernaryPlot(atip=jj[1], btip=jj[2], ctip=jj[3])
    TernaryPoints(x, pch=16, cex=0.5)
    TernaryPoints(startp, pch=16,col="red")
}
```

```{r, label=showsample, fig.cap="Random sample from the posterior PDF", cache=TRUE}
ternary_sampleplot(200, H_mu)
```

Figure \@ref(fig:showsample) shows a ternarny plot of samples from the
posterior PDF following the observation of $a\succ a\succ a\succ
a\succ b\succ c \succ a \succ c\succ b$.  We can use this method to
give a Bayesian estimate for the probability that $p_b\geqslant p_c$:

```{r, label=bayesianbgtc, cache=TRUE}
jj <- rp(1000, H_mu)
```

```{r, label=showbayesianbgtc}
head(jj)
sum(jj[,2] >= jj[,3])
sum(jj[,2] >= jj[,3])/nrow(jj)
```

Above we see that $\operatorname{Pr}(p_b\geqslant p_c)\simeq 0.66$.


# Synthetic race data (`hyper3`)

Here we use `rrace3()` to generate repeated results from a race
between three runners.

```{r singlerrace3example, cache=TRUE}
set.seed(0)
(randomrace <- noquote(rrace3(pn = c(a=6, b=3, c=8), ps = c(a=0.3,b=0.5,c=0.2))))
(S <- ordervec2supp3(randomrace))
maxp(S)
```

Above we see `randomrace` being an order vector for a race with six
`a` clones, 3 `b` clones and 2 `c` clones of PL strengths 0.3, 0.5 and
0.2 respectively.  Thus the first place was a `b`, second place was an
`a`, third place a `c`, and so on.  Object `S` is support function for
this realisation and we also see the maimum likelihood estimate for
the three strengths.  Now we repeatedly run races with these PL
strengths and calculate the maximum likelihood estimate for each
realisation:

```{r repeatedrrace3, cache = TRUE}
x <- t(replicate(50,maxp(ordervec2supp3(rrace3(pn = c(a=16, b=13, c=18), ps = c(a=0.3,b=0.5,c=0.2))))))
```

```{r showx}
head(x)
```

```{r ternaryrrace3, fig.cap="Maximum likelihood estimates of synthetic datasets generated by the `rrace3()` random race function"}
TernaryPlot(atip="a", btip="b", ctip="c")
TernaryPoints(x, pch=16, cex=0.5)
TernaryPoints(c(0.3,0.5,0.2),pch=16,col="red")
```

Figure \@ref(fig:ternaryrrace3) shows an ensemble of estimates of the players' Plackett-Luce
strengths as black dots, and the true value of the strengths
(viz. `c(a=0.3,b=0.5,c=0.2)`) in red.  The estimates cluster around the true value.  It might be interesting to assess whether the estimates 
estimates are Dirichlet and, if so, what parameters the distribution
possesses.














# The `chess` dataset (`hyper2`)

Now generate a synthetic dataset.  Here we will sample from the
posterior of a uniform prior with a likelihood function specified by
the `chess` object (this takes quite a long time):

```{r generatedata, cache=TRUE}
set.seed(0)
xx <- rp(1000,chess)
```

Using the `TernaryPlot()` and `TernaryPoints()` functions is straightforward:
```{r plotdata, fig.cap="Ternary plot of estimated Plackett-Luce strengths of three chess players, using synthetic data"}
jj <- pnames(chess)
TernaryPlot(atip=jj[1],btip=jj[2],ctip=jj[3])
TernaryPoints(xx,cex=0.5)
TernaryPoints(chess_maxp,pch=16,col="red")
```

In figure \@ref(fig:plotdata) we see black circles being samples from
the posterior and the red point is the maximum likelihood estimate for
the three players' strengths.  We can adapt this technique to
higher-dimensional `hyper2` objects.


```{r, label=tcpchess, cache=TRUE}
ternary_contourplot(chess)
```


# The `icons` dataset (`hyper2`)

Consider the `icons` likelihood function:

```{r showicons}
icons
```


We can sample from this object and plot it in different ways:


```{r samplefromicons,cache=TRUE}
n <- 10000
x <- rp(n,icons)
x[sample(n,5),]
```


```{r iconsmatplot, fig.cap="Metropolis-Hastings random sampling of the `icons` dataset: the six Bradley-Terry strengths of each icon"}
matplot(x,type="l",lty=1)
legend("topright",col=1:6,lty=1,legend=pnames(icons))
```

```{r selectjustbigones, fig.cap="Ternary plot of the icons dataset, showing Norfolk Broads (NB, top), Polar Bears (PB, lower right), and everything else (other, lower left).  Small black dots show MLEs of synthetic (Metropolis-Hastings) datasets; large red dot shows MLE for the original dataset"}
wanted <- c(1,3) # NB,PB
xx <- cbind(x[, wanted], fillup=rowSums(x[, -wanted]))
TernaryPlot(atip="NB", btip="PB", ctip="other")
TernaryPoints(xx, cex=0.5, pch=16)
jj <- icons_maxp[wanted]
TernaryPoints(c(jj,1-sum(jj)), pch=16, col="red")
```

Figures \@ref(fig:iconsmatplot) and \@ref(fig:selectjustbigones) show
different aspects of the BT strengths of the six icons of the `icons`
dataset.  Note that figure \@ref(fig:selectjustbigones) is potentially
misleading: due to the sequential correlation of MH sampling, repeated
observations are overplotted and thus under-represented.

